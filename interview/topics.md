# Topics

## [1] 请你说说 TCP 和 UDP 的区别

    TCP和UDP都是传输层的协议，然而两者的区别非常大。TCP 提供面向连接的可靠传输，UDP 提供面向无连接的不可靠传输。UDP 在很多实时性要求高的场景有很好的表现，而TCP在要求数据准确、对速度没有硬性要求的场景有很好的表现。 标准回答 首先 UDP 协议和 TCP 协议都是运输层协议，都是为应用层程序服务，都具有复用（不同的应用层协议可以共用 UDP 协议和 TCP 协议）和分用（将数据报解析之后分发给不同的应用层程序）的功能。UDP 提供面向无连接基于数据报的不可靠传输，TCP 提供面向连接基于字节流的可靠传输。UDP 在很多实时性要求高的场景有很好的表现，而 TCP 在要求数据准确、对速度没有硬性要求的场景有很好的表现。 加分回答 具体的区别详细描述可以是： - UDP协议：面向无连接（不需要三次握手和四次挥手）、尽最大努力交付、面向报文（每次收发都是一整个报文段）、没有拥塞控制不可靠（只管发不管过程和结果）、支持一对一、一对多、多对一和多对多的通信方式、首部开销很小（8字节）。优点是快，没有TCP各种机制，少了很多首部信息和重复确认的过程，节省了大量的网络资源。缺点是不可靠不稳定，只管数据的发送不管过程和结果，网络不好的时候很容易造成数据丢失。又因为网络不好的时候不会影响到主机数据报的发送速率，这对很多实时的应用程序很重要，因为像语音通话、视频会议等要求源主机要以恒定的速率发送数据报，允许网络不好的时候丢失一些数据，但不允许太大的延迟，UDP很适合这种要求。 - TCP协议：是TCP/IP体系中非常复杂的一个协议，面向连接（需要三次握手四次挥手）、单播（只能端对端的连接）、可靠交付（有大量的机制保护TCP连接数据的可靠性）、全双工通讯（允许双方同时发送信息，也是四次挥手的原由）、面向字节流（不保留数据报边界的情况下以字节流的方式进行传输，这也是长连接的由来。）、头部开销大（最少20字节）。优点是可靠、稳定，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开连接用来节约系统资源。缺点是慢，效率低，占用系统资源高，在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。在要求数据准确、对速度没有硬性要求的场景有很好的表现，比如在FTP（文件传输）、HTTP/HTTPS（超文本传输），TCP很适合这种要求。

## [2] 栈内存和堆内存有什么区别？

    管理方式：程序的栈内存大小由编译器决定，由操作系统管理，程序员无需插手；而堆内存由程序员管理。
    空间大小：通常操作系统会对栈内存做一定的限制，比如在Windows上默认的栈空间大小是1M，而在Linux上则是8M，这个大小要远远小于堆空间的大小。堆空间几乎没有任何限制，甚至可以超出物理内存的大小。

    碎片问题：栈内存不会造成内存碎片，因为栈是一种FILO的数据结构，数据的压栈和弹栈有严格的要求。而堆空间则不然，在分配的时候灵活性很高，所以会造成很多的内存碎片，导致性能降低。
    生长方向：在虚拟内存空间中，栈内存的生长方法是沿着内存地址减小的方向；而堆内存的生长方向是沿着地址增大的方向。
    分配方式：栈内存有两种分配方式，静态和动态；而堆内存有只能动态分配。
    分配效率：栈的分配效率要远远高于堆，因为栈内存的分配有操作系统和地层硬件的支持，比如CPU中有专门的寄存器存放栈的地址，栈的压栈和弹栈都有专门的指令集来处理；而堆则不同，一般是通过C和C++标准库中提供的接口来分配内存，C/C++标准库的底层也是调用操作系统的接口，整个机制是比较复杂的，操作系统需要应对很多的复杂的情况，比如如何在保证分配速度的情况下降低内存碎片。

## [3] 线程和协程之间的区别？

    线程是操作系统提供的接口，而协程是语言的标准库提供的。
    TODO

## [4] TCP的五层模型？

    TODO
    TCP五层模型从上至下分别为：应用层，传输层、网络层、数据链路层和物理层。
    应用层：面向用户提供服务，一般来说，不同服务会制定不同的协议，如HTTP/HTTPS，SMTP。应用层主要是将用户需要传输的数据进行封装，然后向下传递给运输层。

    传输层：传输层的主要功能是提供传输的形式，代表性的协议有TCP和UDP。TCP是一种面向连接的协议，它能够提供端到端的的可靠通信，是目前应用最为普遍的一种协议。

    网络层：网络层主要考虑如何组成一个大的网络。
    
    数据链路层：物理层传输的信号是单纯的1和0，数据链路层定义了信号的分组形式，

    物理层：主要是负责用电气特性发送电信号完成传输，物理层会规定网络物理接口的规格，比如光缆、电缆、双绞线和无线电波。

## [5] STL有那些容器？

    关联容器：
    顺序容器：

## [6] Liunx和其他Unix的差别

## [7] 硬链接和软链接的区别？

    链接是文件的一种共享方式，属于POSIX中的概念，主流的文件系统都支持链接。但是链接分为软硬两种，硬链接的inode与文件相同，它实际上指向了和文件同一个硬盘空间的区块。而软链接则不然，软链接本质上只是保存了文件的路径而已，软链接的inode和文件的不同。

|  | hard link | soft link|
| - | - | - |
| 建立 | ln \[file\]\[hard link\]   | ln \-s \[file\] \[soft link\]   |
| inode | 与文件相同 | 与文件不同 |
| 删除文件 | 不受影响 | 失效 |
| 链接目录 | 不能建立 | 可以建立 |
| 修改链接 | 影响文件 | 影响文件 |
| 删除链接 | 不影响文件 | 不影响文件 |

## [8] so和dll的区别

 C++标准并没有堆共享库作任何说明，也就说操作系统有自己的实现自由，不同平台的共享库存在差异。比如，在Linux上的共享库被称为shared obejcts, 一般是so作为文件拓展名，而在Windows平台上，被称为dynamic liked libraries，一般用dll作为拓展名。两种技术方案主要存在以下的差异：
 Unix中的符号是默认导出的，而Windows中需要显式导出

| 操作 | so | dll |
| - | - | - |
| 导出符号 | 默认导出|\-\-declspec(dllexport) |
| 头文件 | #include <dlfcn.h> | #include <windows.h> |
| 加载动态库| dlopen | LoadLibrary |
| 动态获取函数 | dlsym | GetProcAddress |
| 卸载动态库 | int dlclose | FreeLibrary |

## [9] URL输入浏览器之后发生了什么？

tatakai

## [10] 谈谈fork

## [11] 如何查看符号表

    在Linux平台的二进制文件的格式主要是ELF，ELF有两种符号表，第一种是总符号表，另外一种是动态符号表，总符号表会包含动态符号表。动态符号表用关于向其他库或二进制提供动态链接的符号。在调用strip的时候，仅会有动态符号表会保留下来。主要有三种查看符号表的方法：

| 工具 | readelf | nm |  objdump |
| - | - | - | - |
| 查看符号表  | readelf -WCs lib.so | nm -AC lib.so | objdump -Ct lib.so |
| 查看动态符号表 | readelf -WC --dyn-syms lib.so  | nm -ADC lib.so | objdump -CT lib.so   |

## [12] HTTP 1.x 和 HTTP 2的区别是什么？

HTTP2采用二进制传输，HTTP1.x 采用文本传输。
HTTP2的传输性能更高可以同时处理多个请求，相对于HTTP1的文本安全性更高。
HTTP2可以推送资源到客户端。

## [13] HTTP和HTTPS的区别是什么？

HTTPS需要申请CA证书，一般免费的证书是比较少的，因而需要一定的费用。

HTTP的报文在进入TCP这一层之前，如果通过了TLS/SSL加密的话，那么就会变成HTTPS报文，在安全性有极大的提升，HTTPS能够防御中间人攻击，也就是在网络传输这个过程中可以保证安全，但是如果恶意软件直入侵了客户端后者服务端，那么HTTPS也无能为力。HTTP和HTTPS的端口也有区别，分别是80和443。

<https://blog.csdn.net/weixin_43126297/article/details/125613576>

<https://www.jianshu.com/p/d3edc375467e>

## [14]
