# BIO
## 1. 概述
UNIX有一条非常著名的理念：“一切皆文件”。这既是一句响亮的口号，也是一种深刻的设计哲理。在条理念的指导下，UNIX操作系统不仅大大降低了实现的复杂度，也让程序员能够更好的学习和掌握UNIX下的编程。UNIX-like的操作系统比之Windows，system call的数量要少很多，这大大降低了程序员的学习负担。
## 2. 文件描述符
在UNIX内核的角度看，任何文件都通过文件描述符（file discriptor）对外作为资源句柄。文件描述符是一个非负整型数类型，当应用需要打开一个文件或新建一个文件时，通过UNIX的系统调用就能拿到一个文件描述符。
请注意，按照“一切皆文件”的理念，应用打开的不仅仅是常规意义上的文件。计算机的输入输出也是以文件的概念抽象的，输入输出设备在工作时，可以视为对文件的读取和写入。在POSIX标准中，以文件描述符0，1，2分别对应标准输入，标准输出，标准输入。更严谨的方式是使用STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO。

## 3.打开文件
调用open或openat函数可以打开或者创建一个文件，open和openat返回的文件描述符一定是最小的且未使用的值。
```C++
#include <fcntl.h>
int open(const char *path, int oflag, .../*mode_t mode */);

int openat(int fd, const char *path, int oflag, .../*mode_t mode */);
```
返回值：非负整数，表示文件描述符，打开成功；-1，表示打开失败。

这里需要注意的是函数各个参数的含义，这点非常重要，如果你连打开文件时的参数都不明白，那么后续对文件的操作都建立在一个模糊基础上。
1. open

    open的第一个参数是path，类型是c风格的字符串。path的作用是告诉操作系统你要打开的文件。path可以是绝对路径也可以是相对路径。

    open的第二个参数是oflag，这个参数告诉操作系统将要以何种模式打开文件，它本质上是一个掩码。各种选项通过或运算进行设置。最常见的选项是以下三个：
    O_RDONLY - 以只读模式打开，通常实现为0。

    O_WRONLY - 以只写模式打开，通常实现为1。

    O_RDWR - 以可读可写模式打开，通常实现为2。

    O_EXEC - 以只执行模式打开。

    O_SEARCH - 只搜索打开(适用于目录)。//支持很少。

    以上5个选项必须且只能选择一个，而下列选项是可选的：

    O_APPEND - 每次写时都把文件追加到文件的末尾。

    O_CLOEXEC - 把FD_CLOEXEC常量设置为文件描述符号。

    O_CREAT - 若此文件不存在则创建它。使用次选项时，open函数需要同时说明第三参数mode，用来制定文件的访问权限位。

    O_DIRECTORY - 若path引用的不是目录，则返回错误。

    O_EXCL - 如果同时制定了O_CREAT，而文件已经存在，那么就会出错。这个方法可以检测文件是否存在，如果不存在则创建此文件。

    O_NOCTTY - 如果path引用的是终端设备，则不会将改设备分配作为此进程的控制终端。

    O_NOFOLLOW - 如果path引用的是一个符号链接，则出错。

    O_NONBLOCK - 如果path引用是一个FIFO，一个块特殊文件或一个字符特殊文件，则将此选项为文件的本次打开操作和后续的IO操作设置为非阻塞方式。

    O_SYNC - 每次的write都等待IO设备的操作完成。

    O_TRUNC - 如果此文件存在，而且为只写或读写打开，则将长度截断为0.

    O_TTY_INIT - 如果打开一个还没打开的终端设备，设置非标准的termio参数值，使其符合 Single UNIX  Specification。（不知所云）

    O_DSYNC - 使每次write都要等待物理IO完成，但是如果写操作不影响读取刚写入的数据 

    O_RSYNC - 使得每一个以文件描述符作为参数进行的read操作等待，直到所有的对文件的同一部分挂起的写操作都完成。
2. openat
   区分openat和open的参数就是fd，openat在一定情况下可以退化为open函数。
   （1）如果path参数指定的是绝对路径，那么这种情况下，fd参数将被忽略，openat退化成open
   （2）如果path参数指定的是相对路径，那么fd就是path的参照地址，这种情况下openat功能比open更强大。
   （3）如果path参数指定的是相对路径，但是fd参数为AT_FDCWD，在这种情况下，路径名在当前的工作目录中获取，openat函数退化为open。

## 4. 创建文件
从前文来看，open的功能是非常强大的，不仅可以打开文件，也能创建文件。但是UNIX中还是提供了creat函数来创建文件
```C++
#include <fcntl.h>
int creat(const char *path, mode_t mode);
```
返回值：创建成功则返回文件描述符，创建失败则返回-1。

creat函数等价于open(path, O_WRONLY | O_CREAT | O_TRUNC, mode)；
于是你会感到疑惑，UNIX的哲学不是KISS吗？为什么会提供类似的功能？实际上，这个是历史原因。早先的open远不如现在强大，因此需要单独一个creat函数，但是现在，open的功能已经能够覆盖creat函数，因此creat函数就显得多余了。creat的一个不足之处在于只能以WRONLY的方式打开文件，这样的限制使得，很多情况下creat之后需要重新open才能读取文件中的内容。这就非常麻烦了，所以后来UNIX不断强化了open的功能。
现在用open(path, O_RDWR|O_CREAT|O_TRUNC, mode)可以避免上述情况中重新open的缺陷。

## 5.关闭文件
调用close关闭文件。
```C++
#include <unistd.h>
int close(int fd);
```
返回值：0表示成功关闭；-1表示出错。
关闭一个文件时，还会释放这个进程加在这个文件上的所有记录锁。
当一个进程终止时，内核自动关闭它所有的打开文件。因此很多程序都懒得关闭文件描述符。

## 6.偏移量
每个打开的文件都有一个与之关联的”当前文件的偏移量“（current file offset）。它通常是一个非负整数，用以度量从文件开始处的字节数。通常，读写操作都是从当前文件的偏移量开始，并且读和写都会引起偏移量的增加。在文件刚打开时，除非指定了O_APPEND，否则都是从0开始。
```C++
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```
返回值：若成功，返回新的的文件偏移量；若出错，则返回-1。
对参数offset的解释与参数whence的值有关。


如果whence是SEEK_SET，则将偏移量设置为从开始处offset个字节。

如果whence是SEEK_CUR，则将偏移量设置为从当前处offset个字节，offset可以为负。

如果whence是SEEK_END，则将偏移量设置为从末尾处offset个字节，offset可以为负。

使用lseek(fd, 0 ,SEEK_CUR)可以返回文件的当前偏移量。这种方法还能用于测试文件是否支持设置偏移量，如果文件描述符不支持设置便宜量则会返回-1。

虽然文件的偏移量通常是一个非负整数，但是off_t是带符号的，所以说负的偏移量也不是完全不可能。因此在检查lseek的返回值时不能简单判断是否为负，而是一定要判断是否等于-1。只有等于-1的情况下才是出错的情况。

文件的偏移量可以大雨文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中形成一个空洞，这一点是允许的。位于文件中没有写过的字节都会被读为0。文件的空洞并不要求在占据物理空间，具体的处理与操作系统的实现有关。


## 7. read
调用read从文件中读取数据
```C++
#include <uunistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
```
read的返回值情况非常复杂：
（1）0，表示读到了文件末尾（EOF），
（2）-1，表示读取出错。
（3）其他数值，表示当前读取到的字节数。

read函数的作用是，从文件fd中读取nbytes个字节，并将内容拷贝到缓冲buf中。但是有很多情况会使得，实际读取的字节数量会少于nbytes，具体来说就是以下的情况：

（1）读普通文件时，如果碰到了EOF，那么，返回的值就会少于nbytes，并且在下一次读取时，read返回0。

（2）当从终端读取时，通常一次最多读一行。

（3）当从网络中读取时，通常会小于所要求的字节数。

（4）当从管道和FIFO读时，如果包含的字节少于所需的数量，则只会返回可用的字节数量。

（5）某些特殊的设备。

（6）当一个信号造成中断时，会返回已经读取的数据量。

我们不难发现，read函数应对的情况还是非常复杂的，虽然各种设备都被抽象为文件，但是它们之间的各种固有特性还是不能抹平，对于具体的设备，read的具体操作会有一些差别。

## 8. write
调用write向打开的文件中写入数据
```C++
#include <unistd.h>
ssize_t write(int fd, const void *buf, nbytes);
```
返回值：成功，表示已经写入的字节数，若出错，返回-1。

write函数出错的原因通常是资源不足造成的。

## 9. IO效率
我们发现其中的一个关键因素就是缓冲区，缓冲区的大小完是由程序员的决定的，所以问题就是究竟多大的缓冲区具有较好的效率？APUE上的测试是4096或者8192是比较好的选择，这个与底层硬件的特性有关。