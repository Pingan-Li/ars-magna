# Overview
WebAssembly(abbr. WASM)是一种底层的二进制编码格式，具有安全，高效可移植的特性，它本质上是一种虚拟的Instruction Set Architect(ISA)。它的设计目标是为Web上运行高性能程序提供一个坚实的基础。

WASM具有以下的设计目标：

(1)Fast：执行效率与本地机器码相当，能够尽最大限度利用硬件的性能。

(2)Safe：代码经过验证并在内存安全的沙盒环境中执行，防止数据损坏或安全漏洞。

(3)Well-defined: wasm中的各种概念都被精确的定义。

(4)Hardware-independent：可以在所有现代架构、桌面或移动设备以及嵌入式系统等上编译。

(5)Language-independent:不授予任何特定语言、编程模型或对象模型的特权。

(6)Platform-independent:可以嵌入到浏览器中，作为独立的虚拟机运行，或者集成到其他环境中。

(7)Open：程序可以以简单和通用的方式与其环境互操作。


## 1. Concepts
WebAssembly是围绕以下的概念构建的：

(1) Values(值)

wasm中支持4种基础的数字类型:
int32, int64, fp32, fp64。int32除了用于一般的数字运算之外还作为Boolean和内存的地址。在wasm中没有signed和unsigned的别，整数都被解释为二进制补码的形式。

除了基本的数字类型之外，还有一个128位宽的向量类型表示不同类型的打包数据，可以将2个64-bit数据，4个32-bit数据，8个16-bit，或者16个8-bit数据打包在一起。

(2) Instructions(指令)

wasm的计算模型基于栈式计算机。

(3) Traps(陷阱)

在某些情况下，某些指令可能会产生陷阱，从而立即中止执行。 陷阱不能由 WebAssembly 代码处理，但会报告给外部环境，通常可以在其中捕获它们。

(4) Functions(函数)

代码被组织成单独的函数。 每个函数都将一系列值作为参数，并返回一系列值作为结果。 函数可以相互调用，包括递归调用，从而导致无法直接访问的隐式调用堆栈。 函数还可以声明可用作虚拟寄存器的可变局部变量。

(5) Tables(表)

表是特定元素类型的不透明值的数组。 它允许程序通过动态索引操作数间接选择这些值。 目前，唯一可用的元素类型是无类型函数引用。 因此，程序可以通过对表的动态索引间接调用函数。 例如，这允许通过表索引来模拟函数指针

(6) Linear Memory(线性内存)

线性内存是一个连续的、可变的原始字节数组。 这样的内存是使用初始大小创建的，但可以动态增长。 程序可以在任何字节地址（包括未对齐的）从/向线性存储器加载和存储值。 整数加载和存储可以指定小于相应值类型大小的存储大小。 如果访问不在当前内存大小的范围内，则会发生陷阱。

(7) Modules(模块)

WebAssembly的二进制文件采用Modules的形式，其中包含函数、表和线性内存的定义，以及可变或不可变的全局变量。 也可以导入定义，指定模块/名称对和合适的类型。 每个定义都可以选择以一个或多个名称导出。除了定义之外，模块还可以为它们的内存或表定义初始化数据，这些数据采用复制到给定偏移量的段的形式。他们还可以定义一个自动执行的`启动函数`。

(8) Embedder(嵌入器)

WebAssembly 实现通常会嵌入到宿主环境中。 该环境定义了如何启动模块加载、如何提供导入（包括主机端定义）以及如何访问导出。 但是，任何特定嵌入的细节都超出了本规范的范围，而是由互补的、特定于环境的 API 定义提供。

## 2. 语义三阶段

从概念上来看，wasm的语义分为三个阶段：Decoding, Validation, Execution。

### 2.1 Decoding
WebAssembly以二进制格式分发。 解码处理该格式并将其转换为模块的内部表示。 在本规范中，这种表示是通过抽象语法建模的，但实际的实现可以直接编译为机器代码。

### 2.2 Validation
解码的模块必须是有效的。验证检查许多格式良好的条件，以保证模块是有意义和安全的。特别是对函数及其主体中的指令序列进行类型检查，例如确保一致地使用操作数堆栈。
### 2.3 Execution
一个有效的模块是可被执行的。执行过程又可以被细分为：Instantiation和Invocation。

(1) Instantiation(实例化)

模块实例是模块的动态表示，具有自己的状态和执行堆栈。 实例化执行模块主体本身，给定所有导入的定义。 它初始化全局变量、内存和表，并调用模块的启动函数（如果已定义）。 它返回模块导出的实例。

(2) Invocation(调用)

一旦实例化，可以通过调用模块实例上的导出函数来启动进一步的 WebAssembly 计算。 给定所需的参数，执行相应的函数并返回其结果。