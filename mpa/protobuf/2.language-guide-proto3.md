# Language Guide(proto 3)

## 定义消息类型

```protobuf
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}
```

第一行声明了protobuf的语法版本，如果要使用proto3，则必须声明，否则protoc会认为你使用的是proto2的版本。

### 指定字段类型

上面的示例中，所有的字段都是标量类型：两个整数类型和一个字符串类型，但是您也可以为字段指定符合类型，包括枚举和其他消息类型。

### 指定字段序号

消息中的每个字段都有一个唯一的编号，这些字段编号用于表示消息二进制格式的字段，一旦确定就不应该改动。1～15的字段编码只需一个字节编码，而16～2047的序号需要两个字节，所以最频繁的字段应该放在1～15的范围内。

可以指定的最小字段编号为1,最大字段编号为2^29-1，即536,870,911。不能指定19000到19999（`FieldDescriptor::kFirstReservedNumber` ~ `FieldDescriptor::kLastReservedNumber`）之间的编号，因为这个范围是字段保留的范围。

### 指定字段规则

消息字段可以是以下字段之一：

`singular`:一个良好定义的消息可以有0或1个singular字段，

`optional`:

`repeated`:

`map`:

### 添加注释

语法与C/C++类似。

### 从.proto文件中会生成什么？

当您在.proto上运行协议缓冲区编译器时，编译器会以您选择的语言生成代码，您需要使用文件中描述的消息类型，包括获取和设置字段值、将消息序列化到输出流以及从输入流解析消息。对于C++，编译器从每个.proto生成一个.h和.cc文件，文件中描述的每个消息类型都有一个类。

## Scalar Value Types

标量消息字段可以具有以下类型之一–该表显示.proto文件中指定的类型以及自动生成的类中的相应类型：
| .proto Type | Notes | C++ type|
| - | - | - |
| double | 双精度浮点 | double |
| float | 单精度浮点 | float |
| int32 | 使用可变长度编码。对负数编码效率低下–如果字段可能有负值，请改用sint32。 | int32 |
| int64 | 使用可变长度编码。对负数编码效率低下–如果字段可能有负值，请改用sint64。 | int64 |
| uint32 | 使用可变长度编码。 | uint32 |
| uint64 | 使用可变长度编码。 | uint64 |
| sint32 | 使用可变长度编码。有符号整数类型，这些比int32更有效地编码负数。 | int32 |
| sint64 | 使用可变长度编码。有符号整数类型，这些比int64更有效地编码负数。 | int64 |
| fixed32 | 固定四个字节，在2^28以上值更加高效 | uint32 |
| fixed64 | 固定八个字节，在2^56以上值更加高效 | uint64 |
| sfixed32 | 固定四个字节 | int32 |
| sfixed64 | 固定八个字节| int64 |
| bool | | bool |
| string | 必须是UTF-8编码或者7bit ASCII编码，并且长度不能大于2^32 | string |
| bytes | 任意形式的字节序列，但是长度不能大与2^32 |string |

## 默认值

解析消息时，如果编码消息不包含特定的单一元素，则解析对象中的对应
字段将设置为该字段的默认值。这些默认值是特定于类型的：

string: 空字符串

byte: 空字节序号

bool: false

numberic: zero

enum: 第一个定义的枚举值，必须是0

message: 由语言决定。